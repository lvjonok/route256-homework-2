package app

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/lvjonok/homework-2/internal/app.DB -o ./db_mock.go -n DBMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/lvjonok/homework-2/internal/models"
)

// DBMock implements DB
type DBMock struct {
	t minimock.Tester

	funcCreateProblem          func(ctx context.Context, p1 models.Problem) (err error)
	inspectFuncCreateProblem   func(ctx context.Context, p1 models.Problem)
	afterCreateProblemCounter  uint64
	beforeCreateProblemCounter uint64
	CreateProblemMock          mDBMockCreateProblem

	funcGetProblem          func(ctx context.Context, i1 models.ID) (pp1 *models.Problem, err error)
	inspectFuncGetProblem   func(ctx context.Context, i1 models.ID)
	afterGetProblemCounter  uint64
	beforeGetProblemCounter uint64
	GetProblemMock          mDBMockGetProblem

	funcGetProblemByTaskNumber          func(ctx context.Context, i1 int) (pp1 *models.Problem, err error)
	inspectFuncGetProblemByTaskNumber   func(ctx context.Context, i1 int)
	afterGetProblemByTaskNumberCounter  uint64
	beforeGetProblemByTaskNumberCounter uint64
	GetProblemByTaskNumberMock          mDBMockGetProblemByTaskNumber

	funcGetRandomProblem          func(ctx context.Context) (pp1 *models.Problem, err error)
	inspectFuncGetRandomProblem   func(ctx context.Context)
	afterGetRandomProblemCounter  uint64
	beforeGetRandomProblemCounter uint64
	GetRandomProblemMock          mDBMockGetRandomProblem
}

// NewDBMock returns a mock for DB
func NewDBMock(t minimock.Tester) *DBMock {
	m := &DBMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateProblemMock = mDBMockCreateProblem{mock: m}
	m.CreateProblemMock.callArgs = []*DBMockCreateProblemParams{}

	m.GetProblemMock = mDBMockGetProblem{mock: m}
	m.GetProblemMock.callArgs = []*DBMockGetProblemParams{}

	m.GetProblemByTaskNumberMock = mDBMockGetProblemByTaskNumber{mock: m}
	m.GetProblemByTaskNumberMock.callArgs = []*DBMockGetProblemByTaskNumberParams{}

	m.GetRandomProblemMock = mDBMockGetRandomProblem{mock: m}
	m.GetRandomProblemMock.callArgs = []*DBMockGetRandomProblemParams{}

	return m
}

type mDBMockCreateProblem struct {
	mock               *DBMock
	defaultExpectation *DBMockCreateProblemExpectation
	expectations       []*DBMockCreateProblemExpectation

	callArgs []*DBMockCreateProblemParams
	mutex    sync.RWMutex
}

// DBMockCreateProblemExpectation specifies expectation struct of the DB.CreateProblem
type DBMockCreateProblemExpectation struct {
	mock    *DBMock
	params  *DBMockCreateProblemParams
	results *DBMockCreateProblemResults
	Counter uint64
}

// DBMockCreateProblemParams contains parameters of the DB.CreateProblem
type DBMockCreateProblemParams struct {
	ctx context.Context
	p1  models.Problem
}

// DBMockCreateProblemResults contains results of the DB.CreateProblem
type DBMockCreateProblemResults struct {
	err error
}

// Expect sets up expected params for DB.CreateProblem
func (mmCreateProblem *mDBMockCreateProblem) Expect(ctx context.Context, p1 models.Problem) *mDBMockCreateProblem {
	if mmCreateProblem.mock.funcCreateProblem != nil {
		mmCreateProblem.mock.t.Fatalf("DBMock.CreateProblem mock is already set by Set")
	}

	if mmCreateProblem.defaultExpectation == nil {
		mmCreateProblem.defaultExpectation = &DBMockCreateProblemExpectation{}
	}

	mmCreateProblem.defaultExpectation.params = &DBMockCreateProblemParams{ctx, p1}
	for _, e := range mmCreateProblem.expectations {
		if minimock.Equal(e.params, mmCreateProblem.defaultExpectation.params) {
			mmCreateProblem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateProblem.defaultExpectation.params)
		}
	}

	return mmCreateProblem
}

// Inspect accepts an inspector function that has same arguments as the DB.CreateProblem
func (mmCreateProblem *mDBMockCreateProblem) Inspect(f func(ctx context.Context, p1 models.Problem)) *mDBMockCreateProblem {
	if mmCreateProblem.mock.inspectFuncCreateProblem != nil {
		mmCreateProblem.mock.t.Fatalf("Inspect function is already set for DBMock.CreateProblem")
	}

	mmCreateProblem.mock.inspectFuncCreateProblem = f

	return mmCreateProblem
}

// Return sets up results that will be returned by DB.CreateProblem
func (mmCreateProblem *mDBMockCreateProblem) Return(err error) *DBMock {
	if mmCreateProblem.mock.funcCreateProblem != nil {
		mmCreateProblem.mock.t.Fatalf("DBMock.CreateProblem mock is already set by Set")
	}

	if mmCreateProblem.defaultExpectation == nil {
		mmCreateProblem.defaultExpectation = &DBMockCreateProblemExpectation{mock: mmCreateProblem.mock}
	}
	mmCreateProblem.defaultExpectation.results = &DBMockCreateProblemResults{err}
	return mmCreateProblem.mock
}

//Set uses given function f to mock the DB.CreateProblem method
func (mmCreateProblem *mDBMockCreateProblem) Set(f func(ctx context.Context, p1 models.Problem) (err error)) *DBMock {
	if mmCreateProblem.defaultExpectation != nil {
		mmCreateProblem.mock.t.Fatalf("Default expectation is already set for the DB.CreateProblem method")
	}

	if len(mmCreateProblem.expectations) > 0 {
		mmCreateProblem.mock.t.Fatalf("Some expectations are already set for the DB.CreateProblem method")
	}

	mmCreateProblem.mock.funcCreateProblem = f
	return mmCreateProblem.mock
}

// When sets expectation for the DB.CreateProblem which will trigger the result defined by the following
// Then helper
func (mmCreateProblem *mDBMockCreateProblem) When(ctx context.Context, p1 models.Problem) *DBMockCreateProblemExpectation {
	if mmCreateProblem.mock.funcCreateProblem != nil {
		mmCreateProblem.mock.t.Fatalf("DBMock.CreateProblem mock is already set by Set")
	}

	expectation := &DBMockCreateProblemExpectation{
		mock:   mmCreateProblem.mock,
		params: &DBMockCreateProblemParams{ctx, p1},
	}
	mmCreateProblem.expectations = append(mmCreateProblem.expectations, expectation)
	return expectation
}

// Then sets up DB.CreateProblem return parameters for the expectation previously defined by the When method
func (e *DBMockCreateProblemExpectation) Then(err error) *DBMock {
	e.results = &DBMockCreateProblemResults{err}
	return e.mock
}

// CreateProblem implements DB
func (mmCreateProblem *DBMock) CreateProblem(ctx context.Context, p1 models.Problem) (err error) {
	mm_atomic.AddUint64(&mmCreateProblem.beforeCreateProblemCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateProblem.afterCreateProblemCounter, 1)

	if mmCreateProblem.inspectFuncCreateProblem != nil {
		mmCreateProblem.inspectFuncCreateProblem(ctx, p1)
	}

	mm_params := &DBMockCreateProblemParams{ctx, p1}

	// Record call args
	mmCreateProblem.CreateProblemMock.mutex.Lock()
	mmCreateProblem.CreateProblemMock.callArgs = append(mmCreateProblem.CreateProblemMock.callArgs, mm_params)
	mmCreateProblem.CreateProblemMock.mutex.Unlock()

	for _, e := range mmCreateProblem.CreateProblemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateProblem.CreateProblemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateProblem.CreateProblemMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateProblem.CreateProblemMock.defaultExpectation.params
		mm_got := DBMockCreateProblemParams{ctx, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateProblem.t.Errorf("DBMock.CreateProblem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateProblem.CreateProblemMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateProblem.t.Fatal("No results are set for the DBMock.CreateProblem")
		}
		return (*mm_results).err
	}
	if mmCreateProblem.funcCreateProblem != nil {
		return mmCreateProblem.funcCreateProblem(ctx, p1)
	}
	mmCreateProblem.t.Fatalf("Unexpected call to DBMock.CreateProblem. %v %v", ctx, p1)
	return
}

// CreateProblemAfterCounter returns a count of finished DBMock.CreateProblem invocations
func (mmCreateProblem *DBMock) CreateProblemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProblem.afterCreateProblemCounter)
}

// CreateProblemBeforeCounter returns a count of DBMock.CreateProblem invocations
func (mmCreateProblem *DBMock) CreateProblemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProblem.beforeCreateProblemCounter)
}

// Calls returns a list of arguments used in each call to DBMock.CreateProblem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateProblem *mDBMockCreateProblem) Calls() []*DBMockCreateProblemParams {
	mmCreateProblem.mutex.RLock()

	argCopy := make([]*DBMockCreateProblemParams, len(mmCreateProblem.callArgs))
	copy(argCopy, mmCreateProblem.callArgs)

	mmCreateProblem.mutex.RUnlock()

	return argCopy
}

// MinimockCreateProblemDone returns true if the count of the CreateProblem invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockCreateProblemDone() bool {
	for _, e := range m.CreateProblemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateProblemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateProblemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateProblem != nil && mm_atomic.LoadUint64(&m.afterCreateProblemCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateProblemInspect logs each unmet expectation
func (m *DBMock) MinimockCreateProblemInspect() {
	for _, e := range m.CreateProblemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.CreateProblem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateProblemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateProblemCounter) < 1 {
		if m.CreateProblemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.CreateProblem")
		} else {
			m.t.Errorf("Expected call to DBMock.CreateProblem with params: %#v", *m.CreateProblemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateProblem != nil && mm_atomic.LoadUint64(&m.afterCreateProblemCounter) < 1 {
		m.t.Error("Expected call to DBMock.CreateProblem")
	}
}

type mDBMockGetProblem struct {
	mock               *DBMock
	defaultExpectation *DBMockGetProblemExpectation
	expectations       []*DBMockGetProblemExpectation

	callArgs []*DBMockGetProblemParams
	mutex    sync.RWMutex
}

// DBMockGetProblemExpectation specifies expectation struct of the DB.GetProblem
type DBMockGetProblemExpectation struct {
	mock    *DBMock
	params  *DBMockGetProblemParams
	results *DBMockGetProblemResults
	Counter uint64
}

// DBMockGetProblemParams contains parameters of the DB.GetProblem
type DBMockGetProblemParams struct {
	ctx context.Context
	i1  models.ID
}

// DBMockGetProblemResults contains results of the DB.GetProblem
type DBMockGetProblemResults struct {
	pp1 *models.Problem
	err error
}

// Expect sets up expected params for DB.GetProblem
func (mmGetProblem *mDBMockGetProblem) Expect(ctx context.Context, i1 models.ID) *mDBMockGetProblem {
	if mmGetProblem.mock.funcGetProblem != nil {
		mmGetProblem.mock.t.Fatalf("DBMock.GetProblem mock is already set by Set")
	}

	if mmGetProblem.defaultExpectation == nil {
		mmGetProblem.defaultExpectation = &DBMockGetProblemExpectation{}
	}

	mmGetProblem.defaultExpectation.params = &DBMockGetProblemParams{ctx, i1}
	for _, e := range mmGetProblem.expectations {
		if minimock.Equal(e.params, mmGetProblem.defaultExpectation.params) {
			mmGetProblem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProblem.defaultExpectation.params)
		}
	}

	return mmGetProblem
}

// Inspect accepts an inspector function that has same arguments as the DB.GetProblem
func (mmGetProblem *mDBMockGetProblem) Inspect(f func(ctx context.Context, i1 models.ID)) *mDBMockGetProblem {
	if mmGetProblem.mock.inspectFuncGetProblem != nil {
		mmGetProblem.mock.t.Fatalf("Inspect function is already set for DBMock.GetProblem")
	}

	mmGetProblem.mock.inspectFuncGetProblem = f

	return mmGetProblem
}

// Return sets up results that will be returned by DB.GetProblem
func (mmGetProblem *mDBMockGetProblem) Return(pp1 *models.Problem, err error) *DBMock {
	if mmGetProblem.mock.funcGetProblem != nil {
		mmGetProblem.mock.t.Fatalf("DBMock.GetProblem mock is already set by Set")
	}

	if mmGetProblem.defaultExpectation == nil {
		mmGetProblem.defaultExpectation = &DBMockGetProblemExpectation{mock: mmGetProblem.mock}
	}
	mmGetProblem.defaultExpectation.results = &DBMockGetProblemResults{pp1, err}
	return mmGetProblem.mock
}

//Set uses given function f to mock the DB.GetProblem method
func (mmGetProblem *mDBMockGetProblem) Set(f func(ctx context.Context, i1 models.ID) (pp1 *models.Problem, err error)) *DBMock {
	if mmGetProblem.defaultExpectation != nil {
		mmGetProblem.mock.t.Fatalf("Default expectation is already set for the DB.GetProblem method")
	}

	if len(mmGetProblem.expectations) > 0 {
		mmGetProblem.mock.t.Fatalf("Some expectations are already set for the DB.GetProblem method")
	}

	mmGetProblem.mock.funcGetProblem = f
	return mmGetProblem.mock
}

// When sets expectation for the DB.GetProblem which will trigger the result defined by the following
// Then helper
func (mmGetProblem *mDBMockGetProblem) When(ctx context.Context, i1 models.ID) *DBMockGetProblemExpectation {
	if mmGetProblem.mock.funcGetProblem != nil {
		mmGetProblem.mock.t.Fatalf("DBMock.GetProblem mock is already set by Set")
	}

	expectation := &DBMockGetProblemExpectation{
		mock:   mmGetProblem.mock,
		params: &DBMockGetProblemParams{ctx, i1},
	}
	mmGetProblem.expectations = append(mmGetProblem.expectations, expectation)
	return expectation
}

// Then sets up DB.GetProblem return parameters for the expectation previously defined by the When method
func (e *DBMockGetProblemExpectation) Then(pp1 *models.Problem, err error) *DBMock {
	e.results = &DBMockGetProblemResults{pp1, err}
	return e.mock
}

// GetProblem implements DB
func (mmGetProblem *DBMock) GetProblem(ctx context.Context, i1 models.ID) (pp1 *models.Problem, err error) {
	mm_atomic.AddUint64(&mmGetProblem.beforeGetProblemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProblem.afterGetProblemCounter, 1)

	if mmGetProblem.inspectFuncGetProblem != nil {
		mmGetProblem.inspectFuncGetProblem(ctx, i1)
	}

	mm_params := &DBMockGetProblemParams{ctx, i1}

	// Record call args
	mmGetProblem.GetProblemMock.mutex.Lock()
	mmGetProblem.GetProblemMock.callArgs = append(mmGetProblem.GetProblemMock.callArgs, mm_params)
	mmGetProblem.GetProblemMock.mutex.Unlock()

	for _, e := range mmGetProblem.GetProblemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetProblem.GetProblemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProblem.GetProblemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProblem.GetProblemMock.defaultExpectation.params
		mm_got := DBMockGetProblemParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProblem.t.Errorf("DBMock.GetProblem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProblem.GetProblemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProblem.t.Fatal("No results are set for the DBMock.GetProblem")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetProblem.funcGetProblem != nil {
		return mmGetProblem.funcGetProblem(ctx, i1)
	}
	mmGetProblem.t.Fatalf("Unexpected call to DBMock.GetProblem. %v %v", ctx, i1)
	return
}

// GetProblemAfterCounter returns a count of finished DBMock.GetProblem invocations
func (mmGetProblem *DBMock) GetProblemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProblem.afterGetProblemCounter)
}

// GetProblemBeforeCounter returns a count of DBMock.GetProblem invocations
func (mmGetProblem *DBMock) GetProblemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProblem.beforeGetProblemCounter)
}

// Calls returns a list of arguments used in each call to DBMock.GetProblem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProblem *mDBMockGetProblem) Calls() []*DBMockGetProblemParams {
	mmGetProblem.mutex.RLock()

	argCopy := make([]*DBMockGetProblemParams, len(mmGetProblem.callArgs))
	copy(argCopy, mmGetProblem.callArgs)

	mmGetProblem.mutex.RUnlock()

	return argCopy
}

// MinimockGetProblemDone returns true if the count of the GetProblem invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockGetProblemDone() bool {
	for _, e := range m.GetProblemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProblemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProblemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProblem != nil && mm_atomic.LoadUint64(&m.afterGetProblemCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProblemInspect logs each unmet expectation
func (m *DBMock) MinimockGetProblemInspect() {
	for _, e := range m.GetProblemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.GetProblem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProblemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProblemCounter) < 1 {
		if m.GetProblemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.GetProblem")
		} else {
			m.t.Errorf("Expected call to DBMock.GetProblem with params: %#v", *m.GetProblemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProblem != nil && mm_atomic.LoadUint64(&m.afterGetProblemCounter) < 1 {
		m.t.Error("Expected call to DBMock.GetProblem")
	}
}

type mDBMockGetProblemByTaskNumber struct {
	mock               *DBMock
	defaultExpectation *DBMockGetProblemByTaskNumberExpectation
	expectations       []*DBMockGetProblemByTaskNumberExpectation

	callArgs []*DBMockGetProblemByTaskNumberParams
	mutex    sync.RWMutex
}

// DBMockGetProblemByTaskNumberExpectation specifies expectation struct of the DB.GetProblemByTaskNumber
type DBMockGetProblemByTaskNumberExpectation struct {
	mock    *DBMock
	params  *DBMockGetProblemByTaskNumberParams
	results *DBMockGetProblemByTaskNumberResults
	Counter uint64
}

// DBMockGetProblemByTaskNumberParams contains parameters of the DB.GetProblemByTaskNumber
type DBMockGetProblemByTaskNumberParams struct {
	ctx context.Context
	i1  int
}

// DBMockGetProblemByTaskNumberResults contains results of the DB.GetProblemByTaskNumber
type DBMockGetProblemByTaskNumberResults struct {
	pp1 *models.Problem
	err error
}

// Expect sets up expected params for DB.GetProblemByTaskNumber
func (mmGetProblemByTaskNumber *mDBMockGetProblemByTaskNumber) Expect(ctx context.Context, i1 int) *mDBMockGetProblemByTaskNumber {
	if mmGetProblemByTaskNumber.mock.funcGetProblemByTaskNumber != nil {
		mmGetProblemByTaskNumber.mock.t.Fatalf("DBMock.GetProblemByTaskNumber mock is already set by Set")
	}

	if mmGetProblemByTaskNumber.defaultExpectation == nil {
		mmGetProblemByTaskNumber.defaultExpectation = &DBMockGetProblemByTaskNumberExpectation{}
	}

	mmGetProblemByTaskNumber.defaultExpectation.params = &DBMockGetProblemByTaskNumberParams{ctx, i1}
	for _, e := range mmGetProblemByTaskNumber.expectations {
		if minimock.Equal(e.params, mmGetProblemByTaskNumber.defaultExpectation.params) {
			mmGetProblemByTaskNumber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProblemByTaskNumber.defaultExpectation.params)
		}
	}

	return mmGetProblemByTaskNumber
}

// Inspect accepts an inspector function that has same arguments as the DB.GetProblemByTaskNumber
func (mmGetProblemByTaskNumber *mDBMockGetProblemByTaskNumber) Inspect(f func(ctx context.Context, i1 int)) *mDBMockGetProblemByTaskNumber {
	if mmGetProblemByTaskNumber.mock.inspectFuncGetProblemByTaskNumber != nil {
		mmGetProblemByTaskNumber.mock.t.Fatalf("Inspect function is already set for DBMock.GetProblemByTaskNumber")
	}

	mmGetProblemByTaskNumber.mock.inspectFuncGetProblemByTaskNumber = f

	return mmGetProblemByTaskNumber
}

// Return sets up results that will be returned by DB.GetProblemByTaskNumber
func (mmGetProblemByTaskNumber *mDBMockGetProblemByTaskNumber) Return(pp1 *models.Problem, err error) *DBMock {
	if mmGetProblemByTaskNumber.mock.funcGetProblemByTaskNumber != nil {
		mmGetProblemByTaskNumber.mock.t.Fatalf("DBMock.GetProblemByTaskNumber mock is already set by Set")
	}

	if mmGetProblemByTaskNumber.defaultExpectation == nil {
		mmGetProblemByTaskNumber.defaultExpectation = &DBMockGetProblemByTaskNumberExpectation{mock: mmGetProblemByTaskNumber.mock}
	}
	mmGetProblemByTaskNumber.defaultExpectation.results = &DBMockGetProblemByTaskNumberResults{pp1, err}
	return mmGetProblemByTaskNumber.mock
}

//Set uses given function f to mock the DB.GetProblemByTaskNumber method
func (mmGetProblemByTaskNumber *mDBMockGetProblemByTaskNumber) Set(f func(ctx context.Context, i1 int) (pp1 *models.Problem, err error)) *DBMock {
	if mmGetProblemByTaskNumber.defaultExpectation != nil {
		mmGetProblemByTaskNumber.mock.t.Fatalf("Default expectation is already set for the DB.GetProblemByTaskNumber method")
	}

	if len(mmGetProblemByTaskNumber.expectations) > 0 {
		mmGetProblemByTaskNumber.mock.t.Fatalf("Some expectations are already set for the DB.GetProblemByTaskNumber method")
	}

	mmGetProblemByTaskNumber.mock.funcGetProblemByTaskNumber = f
	return mmGetProblemByTaskNumber.mock
}

// When sets expectation for the DB.GetProblemByTaskNumber which will trigger the result defined by the following
// Then helper
func (mmGetProblemByTaskNumber *mDBMockGetProblemByTaskNumber) When(ctx context.Context, i1 int) *DBMockGetProblemByTaskNumberExpectation {
	if mmGetProblemByTaskNumber.mock.funcGetProblemByTaskNumber != nil {
		mmGetProblemByTaskNumber.mock.t.Fatalf("DBMock.GetProblemByTaskNumber mock is already set by Set")
	}

	expectation := &DBMockGetProblemByTaskNumberExpectation{
		mock:   mmGetProblemByTaskNumber.mock,
		params: &DBMockGetProblemByTaskNumberParams{ctx, i1},
	}
	mmGetProblemByTaskNumber.expectations = append(mmGetProblemByTaskNumber.expectations, expectation)
	return expectation
}

// Then sets up DB.GetProblemByTaskNumber return parameters for the expectation previously defined by the When method
func (e *DBMockGetProblemByTaskNumberExpectation) Then(pp1 *models.Problem, err error) *DBMock {
	e.results = &DBMockGetProblemByTaskNumberResults{pp1, err}
	return e.mock
}

// GetProblemByTaskNumber implements DB
func (mmGetProblemByTaskNumber *DBMock) GetProblemByTaskNumber(ctx context.Context, i1 int) (pp1 *models.Problem, err error) {
	mm_atomic.AddUint64(&mmGetProblemByTaskNumber.beforeGetProblemByTaskNumberCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProblemByTaskNumber.afterGetProblemByTaskNumberCounter, 1)

	if mmGetProblemByTaskNumber.inspectFuncGetProblemByTaskNumber != nil {
		mmGetProblemByTaskNumber.inspectFuncGetProblemByTaskNumber(ctx, i1)
	}

	mm_params := &DBMockGetProblemByTaskNumberParams{ctx, i1}

	// Record call args
	mmGetProblemByTaskNumber.GetProblemByTaskNumberMock.mutex.Lock()
	mmGetProblemByTaskNumber.GetProblemByTaskNumberMock.callArgs = append(mmGetProblemByTaskNumber.GetProblemByTaskNumberMock.callArgs, mm_params)
	mmGetProblemByTaskNumber.GetProblemByTaskNumberMock.mutex.Unlock()

	for _, e := range mmGetProblemByTaskNumber.GetProblemByTaskNumberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetProblemByTaskNumber.GetProblemByTaskNumberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProblemByTaskNumber.GetProblemByTaskNumberMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProblemByTaskNumber.GetProblemByTaskNumberMock.defaultExpectation.params
		mm_got := DBMockGetProblemByTaskNumberParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProblemByTaskNumber.t.Errorf("DBMock.GetProblemByTaskNumber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProblemByTaskNumber.GetProblemByTaskNumberMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProblemByTaskNumber.t.Fatal("No results are set for the DBMock.GetProblemByTaskNumber")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetProblemByTaskNumber.funcGetProblemByTaskNumber != nil {
		return mmGetProblemByTaskNumber.funcGetProblemByTaskNumber(ctx, i1)
	}
	mmGetProblemByTaskNumber.t.Fatalf("Unexpected call to DBMock.GetProblemByTaskNumber. %v %v", ctx, i1)
	return
}

// GetProblemByTaskNumberAfterCounter returns a count of finished DBMock.GetProblemByTaskNumber invocations
func (mmGetProblemByTaskNumber *DBMock) GetProblemByTaskNumberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProblemByTaskNumber.afterGetProblemByTaskNumberCounter)
}

// GetProblemByTaskNumberBeforeCounter returns a count of DBMock.GetProblemByTaskNumber invocations
func (mmGetProblemByTaskNumber *DBMock) GetProblemByTaskNumberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProblemByTaskNumber.beforeGetProblemByTaskNumberCounter)
}

// Calls returns a list of arguments used in each call to DBMock.GetProblemByTaskNumber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProblemByTaskNumber *mDBMockGetProblemByTaskNumber) Calls() []*DBMockGetProblemByTaskNumberParams {
	mmGetProblemByTaskNumber.mutex.RLock()

	argCopy := make([]*DBMockGetProblemByTaskNumberParams, len(mmGetProblemByTaskNumber.callArgs))
	copy(argCopy, mmGetProblemByTaskNumber.callArgs)

	mmGetProblemByTaskNumber.mutex.RUnlock()

	return argCopy
}

// MinimockGetProblemByTaskNumberDone returns true if the count of the GetProblemByTaskNumber invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockGetProblemByTaskNumberDone() bool {
	for _, e := range m.GetProblemByTaskNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProblemByTaskNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProblemByTaskNumberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProblemByTaskNumber != nil && mm_atomic.LoadUint64(&m.afterGetProblemByTaskNumberCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProblemByTaskNumberInspect logs each unmet expectation
func (m *DBMock) MinimockGetProblemByTaskNumberInspect() {
	for _, e := range m.GetProblemByTaskNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.GetProblemByTaskNumber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProblemByTaskNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProblemByTaskNumberCounter) < 1 {
		if m.GetProblemByTaskNumberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.GetProblemByTaskNumber")
		} else {
			m.t.Errorf("Expected call to DBMock.GetProblemByTaskNumber with params: %#v", *m.GetProblemByTaskNumberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProblemByTaskNumber != nil && mm_atomic.LoadUint64(&m.afterGetProblemByTaskNumberCounter) < 1 {
		m.t.Error("Expected call to DBMock.GetProblemByTaskNumber")
	}
}

type mDBMockGetRandomProblem struct {
	mock               *DBMock
	defaultExpectation *DBMockGetRandomProblemExpectation
	expectations       []*DBMockGetRandomProblemExpectation

	callArgs []*DBMockGetRandomProblemParams
	mutex    sync.RWMutex
}

// DBMockGetRandomProblemExpectation specifies expectation struct of the DB.GetRandomProblem
type DBMockGetRandomProblemExpectation struct {
	mock    *DBMock
	params  *DBMockGetRandomProblemParams
	results *DBMockGetRandomProblemResults
	Counter uint64
}

// DBMockGetRandomProblemParams contains parameters of the DB.GetRandomProblem
type DBMockGetRandomProblemParams struct {
	ctx context.Context
}

// DBMockGetRandomProblemResults contains results of the DB.GetRandomProblem
type DBMockGetRandomProblemResults struct {
	pp1 *models.Problem
	err error
}

// Expect sets up expected params for DB.GetRandomProblem
func (mmGetRandomProblem *mDBMockGetRandomProblem) Expect(ctx context.Context) *mDBMockGetRandomProblem {
	if mmGetRandomProblem.mock.funcGetRandomProblem != nil {
		mmGetRandomProblem.mock.t.Fatalf("DBMock.GetRandomProblem mock is already set by Set")
	}

	if mmGetRandomProblem.defaultExpectation == nil {
		mmGetRandomProblem.defaultExpectation = &DBMockGetRandomProblemExpectation{}
	}

	mmGetRandomProblem.defaultExpectation.params = &DBMockGetRandomProblemParams{ctx}
	for _, e := range mmGetRandomProblem.expectations {
		if minimock.Equal(e.params, mmGetRandomProblem.defaultExpectation.params) {
			mmGetRandomProblem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRandomProblem.defaultExpectation.params)
		}
	}

	return mmGetRandomProblem
}

// Inspect accepts an inspector function that has same arguments as the DB.GetRandomProblem
func (mmGetRandomProblem *mDBMockGetRandomProblem) Inspect(f func(ctx context.Context)) *mDBMockGetRandomProblem {
	if mmGetRandomProblem.mock.inspectFuncGetRandomProblem != nil {
		mmGetRandomProblem.mock.t.Fatalf("Inspect function is already set for DBMock.GetRandomProblem")
	}

	mmGetRandomProblem.mock.inspectFuncGetRandomProblem = f

	return mmGetRandomProblem
}

// Return sets up results that will be returned by DB.GetRandomProblem
func (mmGetRandomProblem *mDBMockGetRandomProblem) Return(pp1 *models.Problem, err error) *DBMock {
	if mmGetRandomProblem.mock.funcGetRandomProblem != nil {
		mmGetRandomProblem.mock.t.Fatalf("DBMock.GetRandomProblem mock is already set by Set")
	}

	if mmGetRandomProblem.defaultExpectation == nil {
		mmGetRandomProblem.defaultExpectation = &DBMockGetRandomProblemExpectation{mock: mmGetRandomProblem.mock}
	}
	mmGetRandomProblem.defaultExpectation.results = &DBMockGetRandomProblemResults{pp1, err}
	return mmGetRandomProblem.mock
}

//Set uses given function f to mock the DB.GetRandomProblem method
func (mmGetRandomProblem *mDBMockGetRandomProblem) Set(f func(ctx context.Context) (pp1 *models.Problem, err error)) *DBMock {
	if mmGetRandomProblem.defaultExpectation != nil {
		mmGetRandomProblem.mock.t.Fatalf("Default expectation is already set for the DB.GetRandomProblem method")
	}

	if len(mmGetRandomProblem.expectations) > 0 {
		mmGetRandomProblem.mock.t.Fatalf("Some expectations are already set for the DB.GetRandomProblem method")
	}

	mmGetRandomProblem.mock.funcGetRandomProblem = f
	return mmGetRandomProblem.mock
}

// When sets expectation for the DB.GetRandomProblem which will trigger the result defined by the following
// Then helper
func (mmGetRandomProblem *mDBMockGetRandomProblem) When(ctx context.Context) *DBMockGetRandomProblemExpectation {
	if mmGetRandomProblem.mock.funcGetRandomProblem != nil {
		mmGetRandomProblem.mock.t.Fatalf("DBMock.GetRandomProblem mock is already set by Set")
	}

	expectation := &DBMockGetRandomProblemExpectation{
		mock:   mmGetRandomProblem.mock,
		params: &DBMockGetRandomProblemParams{ctx},
	}
	mmGetRandomProblem.expectations = append(mmGetRandomProblem.expectations, expectation)
	return expectation
}

// Then sets up DB.GetRandomProblem return parameters for the expectation previously defined by the When method
func (e *DBMockGetRandomProblemExpectation) Then(pp1 *models.Problem, err error) *DBMock {
	e.results = &DBMockGetRandomProblemResults{pp1, err}
	return e.mock
}

// GetRandomProblem implements DB
func (mmGetRandomProblem *DBMock) GetRandomProblem(ctx context.Context) (pp1 *models.Problem, err error) {
	mm_atomic.AddUint64(&mmGetRandomProblem.beforeGetRandomProblemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRandomProblem.afterGetRandomProblemCounter, 1)

	if mmGetRandomProblem.inspectFuncGetRandomProblem != nil {
		mmGetRandomProblem.inspectFuncGetRandomProblem(ctx)
	}

	mm_params := &DBMockGetRandomProblemParams{ctx}

	// Record call args
	mmGetRandomProblem.GetRandomProblemMock.mutex.Lock()
	mmGetRandomProblem.GetRandomProblemMock.callArgs = append(mmGetRandomProblem.GetRandomProblemMock.callArgs, mm_params)
	mmGetRandomProblem.GetRandomProblemMock.mutex.Unlock()

	for _, e := range mmGetRandomProblem.GetRandomProblemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetRandomProblem.GetRandomProblemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRandomProblem.GetRandomProblemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRandomProblem.GetRandomProblemMock.defaultExpectation.params
		mm_got := DBMockGetRandomProblemParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRandomProblem.t.Errorf("DBMock.GetRandomProblem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRandomProblem.GetRandomProblemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRandomProblem.t.Fatal("No results are set for the DBMock.GetRandomProblem")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetRandomProblem.funcGetRandomProblem != nil {
		return mmGetRandomProblem.funcGetRandomProblem(ctx)
	}
	mmGetRandomProblem.t.Fatalf("Unexpected call to DBMock.GetRandomProblem. %v", ctx)
	return
}

// GetRandomProblemAfterCounter returns a count of finished DBMock.GetRandomProblem invocations
func (mmGetRandomProblem *DBMock) GetRandomProblemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRandomProblem.afterGetRandomProblemCounter)
}

// GetRandomProblemBeforeCounter returns a count of DBMock.GetRandomProblem invocations
func (mmGetRandomProblem *DBMock) GetRandomProblemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRandomProblem.beforeGetRandomProblemCounter)
}

// Calls returns a list of arguments used in each call to DBMock.GetRandomProblem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRandomProblem *mDBMockGetRandomProblem) Calls() []*DBMockGetRandomProblemParams {
	mmGetRandomProblem.mutex.RLock()

	argCopy := make([]*DBMockGetRandomProblemParams, len(mmGetRandomProblem.callArgs))
	copy(argCopy, mmGetRandomProblem.callArgs)

	mmGetRandomProblem.mutex.RUnlock()

	return argCopy
}

// MinimockGetRandomProblemDone returns true if the count of the GetRandomProblem invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockGetRandomProblemDone() bool {
	for _, e := range m.GetRandomProblemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRandomProblemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRandomProblemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRandomProblem != nil && mm_atomic.LoadUint64(&m.afterGetRandomProblemCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRandomProblemInspect logs each unmet expectation
func (m *DBMock) MinimockGetRandomProblemInspect() {
	for _, e := range m.GetRandomProblemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.GetRandomProblem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRandomProblemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRandomProblemCounter) < 1 {
		if m.GetRandomProblemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.GetRandomProblem")
		} else {
			m.t.Errorf("Expected call to DBMock.GetRandomProblem with params: %#v", *m.GetRandomProblemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRandomProblem != nil && mm_atomic.LoadUint64(&m.afterGetRandomProblemCounter) < 1 {
		m.t.Error("Expected call to DBMock.GetRandomProblem")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DBMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateProblemInspect()

		m.MinimockGetProblemInspect()

		m.MinimockGetProblemByTaskNumberInspect()

		m.MinimockGetRandomProblemInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateProblemDone() &&
		m.MinimockGetProblemDone() &&
		m.MinimockGetProblemByTaskNumberDone() &&
		m.MinimockGetRandomProblemDone()
}
